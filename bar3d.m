
function h = bar3d(varargin)
%BAR3D   3-D bar plot.
%   BAR3D(X,Y,Z) plots the 3d bars defined by X, Y and Z, where X and
%   Y are m by n matrices which can be generated by meshgrid from vectors,
%   and Z is an m by n by p matrix. If p is greater than 1, p sets of m by
%   n bars are drawn in the same axes, the default arrangement of bars in
%   the same position but from different sets is being grouped along the
%   x axis, and this default behavior can be modified by setting the
%   parameter 'Arrange'.
%
%   BAR3D(X,Y,Z,C) additionally specifies the color of bars, where C is of
%   the same size as X or Y.
%
%   BAR3D(Z) is similar to BAR3D(X,Y,Z) but uses the column and row
%   indices of the elements in Z as x and y coordinates.
%
%   BAR3D(Z,C) additionally specifies the color of bars.
%
%   BAR3D(...,'Width',width) sets the value of the width of bars.
%
%   BAR3D(...,'Base',base) sets the base value of the plot, where base
%   can be a scalar value or an m by n matrix.
%
%   BAR3D(...,'Arrange',arrange) sets the arrangement of bars if Z is
%   a multidimensional matrix. Available options are 'hold', where bars
%   are plot in the same position, 'x', where bars are grouped along x
%   axis, 'y', where bars are grouped along y axis and 'z' where bars are
%   grouped along z axis or, in other words, stacked together.
%
%   BAR3D(...,'Gap',gap) sets the gap of bars if the arrangement is
%   'x' or 'y', where the gap is considered as a ratio, or 'z', where the
%   gap is considered as a numeric value.
%
%   BAR3D(...,'PropertyName',PropertyValue,...) sets the value of the
%   specified BAR3D property, apart from 'Width', 'Base', 'Arrange' and
%   'Gap'. The property names and values are the same as those of SURF.
%
%   BAR3D(AX,...) plots into AX instead of GCA.
%
%   h = BAR3D returns a handle to a surface plot object or multiple
%   handles to all the surface plot objects. 
%
%   AXIS, CAXIS, COLORMAP, HOLD, SHADING and VIEW set figure, axes, and
%   surface properties which affect the display of the 3d bars.
%
%   Ze-Zheng Wu 10-1-21
narginchk(1, inf);
[~, cax, args] = parseplotapi(varargin{:}, '-mfilename', mfilename);
nargs = length(args);
args = convertStringToCharArgs(args);
hadParentAsPVPair = false;
if nargs > 1
    for p = 1:nargs
        isValid = ~isempty(args{p}) && isCharOrString(args{p});
        hasParentArg = strncmpi(args{p}, 'parent', length(args{p}));
        if isValid && hasParentArg && nargs > p
            cax = args{p+1};
            hadParentAsPVPair = true;
            break;
        end
    end
end
if isempty(cax) || ~hadParentAsPVPair
    if ~isempty(cax) && ~ishghandle(cax, 'Axes')
        parax = cax;
        cax = ancestor(cax, 'Axes');
        nextPlot = 'add';
    else
        showInteractionInfoPanel = isempty(get(groot, 'CurrentFigure'));
        cax = newplot(cax);
        parax = cax;
        nextPlot = cax.NextPlot;
        if showInteractionInfoPanel
            % Maybe open the Interaction Info Panel
            matlab.graphics.internal.InteractionInfoPanel.maybeShow(cax);
        end
    end
else
    cax = newplot(cax);
    parax = cax;
    nextPlot = cax.NextPlot;
end
n = 1;
while n <= nargs && isplottable(args{n})
    n = n + 1;
end
n = n - 1;
w = 0.8;
isWSet = false;
base = 0;
arrange = 'x';
gap = 0;
xyTemplate = [
    NaN, NaN, NaN, NaN, NaN;
    NaN, 1, 1, NaN, NaN;
    1, 1, 1, 1, NaN;
    1, 1, 1, 1, NaN;
    NaN, 1, 1, NaN, NaN;
    NaN, 1, 1, NaN, NaN;
    ];
zTemplate = [
    NaN, NaN, NaN, NaN, NaN;
    NaN, 0, 0, NaN, NaN;
    0, 1, 1, 0, NaN;
    0, 1, 1, 0, NaN;
    NaN, 0, 0, NaN, NaN;
    NaN, 0, 0, NaN, NaN;
    ];
if nargs > 1
    for p = nargs:-1:1
        arg = args{p};
        if strcmpi(arg, 'width')
            w = args{p + 1};
            isWSet = true;
            args([p, p + 1]) = [];
        elseif strcmpi(arg, 'base')
            base = args{p + 1};
            if ~isscalar(base)
                base = kron(base, xyTemplate);
            end
            args([p, p + 1]) = [];
        elseif strcmpi(arg, 'arrange')
            arrange = args{p + 1};
            args([p, p + 1]) = [];
        elseif strcmpi(arg, 'gap')
            gap = args{p + 1};
            args([p, p + 1]) = [];
        end
    end
end
switch(n)
    case 1
        % BAR3D(Z,...)
        [row, col, pag] = size(args{1});
        [x, y] = meshgrid(1:col, 1:row);
        
        x = kron(x, xyTemplate);
        y = kron(y, xyTemplate);
        hh = gobjects(1, pag);
        
        for p = 1:pag
            [xx, yy, zz, base] = arrangeData(...
            x, y, args{1},...
            w, gap, base, p, pag,...
            xyTemplate, zTemplate, arrange);
            hh(p) = surface(xx, yy, zz, args{2:end}, 'Parent', parax);
        end
    case 2
        % BAR3D(Z,C,...)
        [row, col, pag] = size(args{1});
        [x, y] = meshgrid(1:col, 1:row);
        
        x = kron(x, xyTemplate);
        y = kron(y, xyTemplate);
        c = kron(args{2}, xyTemplate);
        hh = gobjects(1, pag);
        
        for p = 1:pag
            [xx, yy, zz, base] = arrangeData(...
            x, y, args{1},...
            w, gap, base, p, pag,...
            xyTemplate, zTemplate, arrange);
            hh(p) = surface(xx, yy, zz, c, args{3:end}, 'Parent', parax);
        end
    case 3
        % BAR3D(X,Y,Z,...)
        if ~isWSet
            w = calculateW(w, args{1}, args{2});
        end
        pag = size(args{3}, 3);
        
        x = kron(args{1}, xyTemplate);
        y = kron(args{2}, xyTemplate);
        hh = gobjects(1, pag);
        
        for p = 1:pag
            [xx, yy, zz, base] = arrangeData(...
            x, y, args{3},...
            w, gap, base, p, pag,...
            xyTemplate, zTemplate, arrange);
            hh(p) = surface(xx, yy, zz, args{4:end}, 'Parent', parax);
        end
    case 4
        % BAR3D(X,Y,Z,C,...)
        if ~isWSet
            w = calculateW(w, args{1}, args{2});
        end
        pag = size(args{3}, 3);
        
        x = kron(args{1}, xyTemplate);
        y = kron(args{2}, xyTemplate);
        c = kron(args{4}, xyTemplate);
        hh = gobjects(1, pag);
        
        for p = 1:pag
            [xx, yy, zz, base] = arrangeData(...
            x, y, args{3},...
            w, gap, base, p, pag,...
            xyTemplate, zTemplate, arrange);
            hh(p) = surface(xx, yy, zz, c, args{5:end}, 'Parent', parax);
        end
end
switch nextPlot
    case {'replaceall','replace'}
        view(cax, 3);
        grid(cax, 'on');
    case {'replacechildren'}
        view(cax, 3);
end
if nargout == 1
    h = hh;
end
    end
function out = isplottable(x)
out = isnumeric(x) || isa(x,'datetime') || isa(x,'duration') || isa(x,'categorical');
end
function w = calculateW(defaultW, x, y)
xDiff = defaultW*(min(min(diff(x, 1, 2), [], 'all'), 1));
yDiff = defaultW*(min(min(diff(y, 1, 1), [], 'all'), 1));
if isempty(xDiff) || xDiff == 0
    xDiff = defaultW;
end
if isempty(yDiff) || yDiff == 0
    yDiff = defaultW;
end
w = min(xDiff, yDiff);
end
function out = isCharOrString(args)
out = (ischar(args) && (isvector(args) || isempty(args))) ||...
    (isstring(args) && isscalar(args));
end
function args = convertStringToCharArgs(args)
if isstring(args)
    args = convertStringsToChars(args);
elseif iscell(args)
    [args{:}] = convertStringsToChars(args{:});
end
end
function [xx, yy, zz, base] = arrangeData(...
    x, y, z,...
    w, gap, base, p, pag,...
    xTemplate, zTemplate, arrange)
xx = x;
yy = y;
switch arrange
    case 'hold'
        xx(:, [1:5:end, 2:5:end]) = x(:, [1:5:end, 2:5:end]) - w/2;
        xx(:, [3:5:end, 4:5:end]) = x(:, [3:5:end, 4:5:end]) + w/2;
        yy([2:6:end, 3:6:end, 6:6:end], :) = y([2:6:end, 3:6:end, 6:6:end], :) - w/2;
        yy([4:6:end, 5:6:end], :) = y([4:6:end, 5:6:end], :) + w/2;
        zz = kron(z(:, :, p), zTemplate) + base;
    case 'x'
        xx(:, [1:5:end, 2:5:end]) = x(:, [1:5:end, 2:5:end]) - w/2 + (p - 1)*w/pag + w/pag*gap/2;
        xx(:, [3:5:end, 4:5:end]) = x(:, [3:5:end, 4:5:end]) - w/2 + p*w/pag - w/pag*gap/2;
        yy([2:6:end, 3:6:end, 6:6:end], :) = y([2:6:end, 3:6:end, 6:6:end], :) - w/2;
        yy([4:6:end, 5:6:end], :) = y([4:6:end, 5:6:end], :) + w/2;
        zz = kron(z(:, :, p), zTemplate) + base;
    case 'y'
        xx(:, [1:5:end, 2:5:end]) = x(:, [1:5:end, 2:5:end]) - w/2;
        xx(:, [3:5:end, 4:5:end]) = x(:, [3:5:end, 4:5:end]) + w/2;
        yy([2:6:end, 3:6:end, 6:6:end], :) = y([2:6:end, 3:6:end, 6:6:end], :) - w/2 + (p - 1)*w/pag + w/pag*gap/2;
        yy([4:6:end, 5:6:end], :) = y([4:6:end, 5:6:end], :) - w/2 + p*w/pag - w/pag*gap/2;
        zz = kron(z(:, :, p), zTemplate) + base;
    case 'z'
        xx(:, [1:5:end, 2:5:end]) = x(:, [1:5:end, 2:5:end]) - w/2;
        xx(:, [3:5:end, 4:5:end]) = x(:, [3:5:end, 4:5:end]) + w/2;
        yy([2:6:end, 3:6:end, 6:6:end], :) = y([2:6:end, 3:6:end, 6:6:end], :) - w/2;
        yy([4:6:end, 5:6:end], :) = y([4:6:end, 5:6:end], :) + w/2;
        zz = kron(z(:, :, p), zTemplate) + base;
        base = kron(z(:, :, p), xTemplate) + sign(kron(z(:, :, p), xTemplate))*gap + base;
end
end
